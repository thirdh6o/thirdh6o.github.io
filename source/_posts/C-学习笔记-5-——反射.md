---
title: C#学习笔记(5)——反射
date: 2026-01-16 17:52:11
tags:
  - C#
categories:
  - 学习笔记
description: 反射、属性与索引器的学习笔记
---
反射指程序可以访问、检测和修改它本身状态或行为的一种能力,允许程序在运行时（Runtime）：
- 加载程序集（Assemblies）
- 创建类型的实例（Objects）
- 调用方法（Methods）
- 访问属性（Properties）
- 操作字段（Fields） 


>简单理解，反射 = 程序在运行时“照镜子”看自己  
## 为什么需要反射
正常情况下，我们在编译时就知道程序会使用哪些类型，哪些方法，哪些属性等。但是在某些情况下，我们需要在运行时动态地加载程序集、创建类型的实例、调用方法、访问属性等。这时候就需要反射。
比如： 
```csharp
User user = new User();
user.Login();
```
这段逻辑是编译期就确定的。  
而反射则是在运行时动态地加载程序集、创建类型的实例、调用方法、访问属性等。
比如：
```csharp
Type type = Type.GetType("MyApp.User");
object obj = Activator.CreateInstance(type);
type.GetMethod("Login").Invoke(obj, null);
```
我们来理解一下上面的代码：
- `Type type = Type.GetType("MyApp.User");`  
  这行代码是在运行时动态地加载程序集、获取类型为 `MyApp.User` 的类型信息。
- `object obj = Activator.CreateInstance(type);`  
  这行代码是在运行时动态地创建类型为 `MyApp.User` 的实例。
- `type.GetMethod("Login").Invoke(obj, null);`  
  这行代码是在运行时动态地调用 `MyApp.User` 类型的 `Login` 方法。  

方法名、类型名可以是字符串、配置文件、数据库、插件中读出来的。
## 通过反射获取成员信息
### Type类
Type 是反射的入口，获取 Type 的三种方式如下:
```csharp
// 方式 1：最常用
Type t1 = typeof(User);

// 方式 2：通过对象
User user = new User();
Type t2 = user.GetType();

// 方式 3：通过字符串（常用于配置/插件）
Type t3 = Type.GetType("MyApp.User");
```
下面的代码中，我们将使用Type类来获取属性、方法、字段等成员信息。
### 获取属性
我们先预设一个 `User` 类：
```csharp
public class User
{
    public string Name { get; set; }

    public User() { }

    public void Login()
    {
        Console.WriteLine("User login");
    }

    private void Secret()
    {
        Console.WriteLine("Secret method");
    }
}
```
Type类的`GetProperties()`方法可以获取所有公共属性（包括继承的）。
```csharp
Type type = typeof(User);
/*
在运行时获取 User 这个类型的“类型信息”
返回的是 System.Type 对象
Type 可以理解为：
“描述一个类本身的元数据对象”
*/
PropertyInfo[] properties = type.GetProperties();
/*
GetProperties()：
获取 所有 public 属性
默认只包含 public 实例属性
PropertyInfo 可以理解为：
“描述一个属性的元数据对象”
*/
foreach (var p in properties)
{
    Console.WriteLine(p.Name);
}
```
针对我们的类 `User`，`GetProperties()` 方法返回的数组 `properties` 中只有一个元素，即 `Name` 属性。故：
```csharp
properties.Length == 1
properties[0].Name == "Name"
```
我们再来看第二种
```csharp
User user = new User();
PropertyInfo prop = type.GetProperty("Name");
prop.SetValue(user, "Alice");
string name = (string)prop.GetValue(user);
/*
通过反射读取属性值
等价于：
string name = user.Name;
*/
```
我们可以看到，通过反射，我们可以动态地设置属性的值，并且可以动态地获取属性的值。
### 获取方法
我们看这一段示例：
```csharp
MethodInfo[] methods = type.GetMethods();
/*
GetMethods()：
获取 所有 public 方法
默认只包含 public 实例方法
MethodInfo 可以理解为：
“描述一个方法的元数据对象”
*/
foreach (var m in methods)
{
    Console.WriteLine(m.Name);
}
```
调用方法的示例：
```csharp
User user = new User();
MethodInfo method = type.GetMethod("Login");

method.Invoke(user, null);
/*
通过反射调用方法
等价于：
user.Login();
*/
```
如果要调用私有方法，需要在 `GetMethod()` 方法中传入 `BindingFlags.NonPublic` 标志。
```csharp
MethodInfo secret = type.GetMethod(
    "Secret",
    BindingFlags.Instance | BindingFlags.NonPublic
);

secret.Invoke(user, null);
/*
通过反射调用私有方法
等价于：
user.Secret();
*/
```
## 通过反射创建对象
Activator 类提供了静态方法 `CreateInstance()` 来创建类型的实例。
```csharp
Type type = typeof(User);
object obj = Activator.CreateInstance(type);
/*
通过反射创建对象
等价于：
User user = new User();
*/
```
typeof(User) 得到一个 Type 对象，它描述了 User 这个类型（相当于“类型说明书”）。
Activator.CreateInstance(type) 会在运行时找到这个 type 对应类型的构造函数，调用它，创建实例并返回（返回类型是 object）  
编译器在这行之后并不能把 obj 推断成 User。因为 CreateInstance 接收的是 Type，返回统一用 object）。  
所以通常要么：
```csharp
// 方式 1：显式转换
User user = (User)Activator.CreateInstance(type);
```
要么用泛型版（更类型安全）：
```csharp
// 方式 2：泛型版
User user = Activator.CreateInstance<User>();
```
## 总结
通过反射，我们可以在运行时动态地获取类型的信息、调用方法、访问属性、创建对象等。 
反射让 C# 在运行时具备“自省”和“动态行为”的能力，是框架的灵魂，但不是业务代码的常客。